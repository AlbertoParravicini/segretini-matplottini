#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Feb 21 16:06:01 2020

@author: aparravi
"""

import scipy.stats as st
import pandas as pd
import matplotlib.pyplot as plt 
import numpy as np

def get_exp_label(val) -> str: 
    """
    :param val: numeric label to format
    :return: label formatted in scientific notation
    
    Format a label in scientific notation, using Latex math font.
    For example, 10000 -> 10^4;
    """
    # Get the power of 10
    exp_val = 0
    remaining_val = val
    while (remaining_val % 10 == 0):
        exp_val += 1
        remaining_val = remaining_val // 10
    if remaining_val > 1:
        return r"$\mathdefault{" + str(remaining_val) + r"·{10}^" + str(exp_val) + r"}$"
    else:
        return r"$\mathdefault{" + r"{10}^" + str(exp_val) + r"}$"
    

def fix_label_length(labels: list, max_length: int=20) -> list:
    """
    :param labels: a list of textual labels
    :return: a list of updated labels
    
    Ensure that all labels are shorter than a given length;
    """
    fixed_labels = []
    for l in labels:
        if len(l) <= max_length:
            fixed_labels += [l]
        else:
            fixed_labels += [l[:max_length-3] + "..."]
    return fixed_labels


def remove_outliers(data, sigmas: int=3):
    """
    :param data: a sequence of numerical data, iterable
    :param sigmas: number of standard deviations outside which a value is consider to be an outlier
    :return: data without outliers
    
    Filter a sequence of data by keeping only values within "sigma" standard deviations from the mean.
    This is a simple way to filter outliers, it is more useful for visualizations than for sound statistical analyses;
    """
    return data[st.zscore(data) < sigmas]


def compute_speedup(X: pd.DataFrame, col_slow: str, col_fast: str, col_speedup: str) -> None:
    """
    Add a column to a dataframe that represents a speedup,
    and "col_slow", "col_fast" are execution times (e.g. CPU and GPU execution time);
    """
    X[col_speedup] = X[col_slow] / X[col_fast]
    
    
def get_upper_ci_size(x, ci=0.95):
    """
    :param x: a sequence of numerical data, iterable
    :param ci: confidence interval to consider
    :return: size of upper confidence interval, size of lower confidence interval, mean
    
    Compute the size of the upper confidence interval,
    i.e. the size between the top of the bar and the top of the error bar as it is generated by seaborn.
    Useful for adding labels above error bars, or to create by hand the error bars;
    """ 
    mean = np.mean(x)
    ci_lower, ci_upper = st.t.interval(ci, len(x) - 1, loc=mean, scale=st.sem(x))
    return ci_upper - mean, mean - ci_lower, mean
    
    
def add_labels(ax: plt.Axes, labels: list=None, vertical_offsets: list=None, patch_num: list=None, fontsize: int=14, rotation: int=0):
    """
    :param ax: current axis, it is assumed that each ax.Patch is a bar over which we want to add a label
    :param labels: optional labels to add. If not present, add the bar height
    :param vertical_offsets: additional vertical offset for each label.
      Useful when displaying error bars (see @get_upper_ci_size), and for fine tuning
    :param patch_num: indices of patches to which we add labels, if some of them should be skipped
    :param fontsize: size of each label
    :param rotation: rotation of the labels (e.g. 90°)
        
    Used to add labels above barplots;
    """
    if not vertical_offsets:
        vertical_offsets = [0] * len(ax.patches)
    if not labels:
        labels = ["{:.2f}".format(p.get_height()) for p in ax.patches]
    patches = []
    if not patch_num:
        patches = ax.patches
    else:
        patches = [p for i, p in enumerate(ax.patches) if i in patch_num]
    
    # Iterate through the list of axes' patches
    lab_num = 0
    for p in patches:
        if labels[lab_num]:
            ax.text(p.get_x() + p.get_width()/2., vertical_offsets[lab_num] + p.get_height(), "{:.2f}x".format(labels[lab_num]), 
                    fontsize=fontsize, color="#2f2f2f", ha='center', va='bottom', rotation=rotation)
        lab_num += 1
        

def update_width(ax: plt.Axes, width: float=1):
    """
    Given an axis with a barplot, scale the width of each bar to the provided percentage,
      and align them to their center;
    """
    for i, patch in enumerate(ax.patches):
        current_width = patch.get_width()
        diff = current_width - width
        # Change the bar width
        patch.set_width(width)
        # Recenter the bar
        patch.set_x(patch.get_x() + 0.5 * diff)